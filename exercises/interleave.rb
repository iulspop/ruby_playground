
# Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with nils.

# Examples:
# interleave([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
# interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, nil]
# interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [1, 4, 7, 2, 5, 8, 3, 6, 9]
# interleave([]) == []

=begin
PROBLEM
input: any number of arrays
ouput: array

model:
build array up, by adding an element from each of the input arrays.

explicit requirements:
  1. any number of input arrays
  2. if an array is shorter than the others, for that element that should be added add nil.

implicit requirements:
  1. any number of elements in the arrays
  2. if input is empty array, then return empty array
  3. only array inputs

EXAMPLES
input:
[1, 2, 3], ["c", "d", "e"]
output:
[1, "c", 2, "d", 3, "e"]

input:
[1, 2, 3], [4, 5]
output:
[1, 4, 2, 5, 3, nil]

input:
[]
output:
[]

DATA STRUCTURE:
input: any number of arrays
output: array
array

ALGORITHM:
1. gather all input arrays into single array
2. create array "final_array"
3. get the length of the longest array "n"
4. loop n times through list of input arrays
   1. push the first element of the array to final_array
5. return final_array

=end

def interleave(*arrays)
  final_array = []
  longest_length = arrays.reduce(0) do |length, array| 
    if array.length > length then array.length
    else length end
  end
    
  longest_length.times do
    arrays.each { |array| final_array.push(array.shift) }
  end
  
  final_array
end

p interleave([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
p interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, nil]
p interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [1, 4, 7, 2, 5, 8, 3, 6, 9]
p interleave([]) == []